// ----------------------------------------------------------------------
// CBhepevt.icc
// ----------------------------------------------------------------------
// Author:  Lynn Garren, Marc Paterno,
//
#include <iomanip>       // needed for formatted output
#include <stdio.h>       // needed for sprintf 

namespace HepMC  {

int CBhepevt::number_children( int index ) 
{
    int firstchild = hptr->jdahep[index][0];
    return ( firstchild>0 ) ? 
	( 1+hptr->jdahep[index][1]-firstchild ) : 0;
}

int CBhepevt::number_parents( int index ) {
    int firstparent = hptr->jmohep[index][0];
    if( firstparent <= 0 ) return 0;
    int secondparent = hptr->jmohep[index][1];
    if( secondparent <= 0 ) return 1;
    return secondparent - firstparent + 1;
}

inline int CBhepevt::first_parent( int index )
{ 
    int parent =  hptr->jmohep[index][0]; 
    return ( parent > 0 && parent <= number_entries() ) ?
				     parent : 0; 
}

inline int CBhepevt::last_parent( int index )
{ 
    // Returns the Index of the LAST parent in the HEPEVT record
    // for particle with Index index.
    // If there is only one parent, the last parent is forced to 
    // be the same as the first parent.
    // If there are no parents for this particle, both the first_parent
    // and the last_parent with return 0.
    // Error checking is done to ensure the parent is always
    // within range ( 0 <= parent <= nhep )
    //
    int firstparent = first_parent(index);
    int parent = hptr->jmohep[index][1]; 
    return ( parent > firstparent && parent <= number_entries() ) 
					       ? parent : firstparent; 
}

inline int CBhepevt::first_child( int index )
{ 
    int child = hptr->jdahep[index][0]; 
    return ( child > 0 && child <= number_entries() ) ?
				   child : 0; 
}

inline int CBhepevt::last_child( int index )
{ 
    // Returns the Index of the LAST child in the HEPEVT record
    // for particle with Index index.
    // If there is only one child, the last child is forced to 
    // be the same as the first child.
    // If there are no children for this particle, both the first_child
    // and the last_child with return 0.
    // Error checking is done to ensure the child is always
    // within range ( 0 <= parent <= nhep )
    //
    int firstchild = first_child(index);
    int child = hptr->jdahep[index][1]; 
    return ( child > firstchild && child <= number_entries() ) 
					    ? child : firstchild;
}

void CBhepevt::print( std::ostream & os ) const
{
    os << "CBhepevt (gets an event from HEPEVT common block)" << std::endl;
    os << "  trustMothers:             " << itsTrustMothers << std::endl;
    os << "  trustMothersAndDaughters: " << itsTrustMothersAndDaughters << std::endl;
}

void CBhepevt::printHEPEVT( std::ostream & os )
{
    // dumps the content of this HEPEVT event to os  (Width is 80)
    os << "________________________________________"
       << "________________________________________" << std::endl;
    os << "***** HEPEVT Common Event#: " 
       << event_number()
       << ", " << number_entries() << " particles (max "
       << max_number_entries() << ") *****";
    os << " Double Precision" << std::endl;
    print_legend(os);
    os << "________________________________________"
       << "________________________________________" << std::endl;
    for ( int i=1; i <= number_entries(); ++i ) {
	printHEPEVTparticle( i, os );
    }
    os << "________________________________________"
       << "________________________________________" << std::endl;
}

void CBhepevt::print_legend( std::ostream & os )
{
    os << "Indx Stat Par- chil-       "
       << "(  P_x,       P_y,       P_z,    Energy,  M ) [GeV]" << std::endl;
    os << "      ID  ents dren    "
       << "Prod (   X,         Y,         Z,        cT)      [mm]" << std::endl;
}	

void CBhepevt::printHEPEVTparticle( int i, std::ostream & os )
{
    // dumps the content HEPEVT particle entry i   (Width is 120)
    // here i is the C array index (i.e. it starts at 0 ... whereas the
    // fortran array index starts at 1) So if there's 100 particles, the
    // last valid index is 100-1=99
    char outline[81];
    sprintf( outline,
	     "%4d %+4d %4d %4d    (%9.3g, %9.3g, %9.3g, %9.3g, %9.3g)"
	     ,i, hptr->isthep[i], first_parent(i), first_child(i),
	     hptr->phep[i][0], hptr->phep[i][1], hptr->phep[i][2], 
	     hptr->phep[i][3], hptr->phep[i][4] );
    os << outline << "\n";
    sprintf( outline,"%+9d %4d %4d    (%9.3g, %9.3g, %9.3g, %9.3g)",
	     // old version was:" (%+9.2e, %+9.2e, %+9.2e, %+9.2e)"
	     hptr->idhep[i], last_parent(i), last_child(i), 
	     hptr->vhep[i][0], hptr->vhep[i][1], hptr->vhep[i][2], 
	     hptr->vhep[i][3] );
    os << outline << std::endl;
}

bool CBhepevt::check_hepevt_consistency( std::ostream & os )
{
    // This method inspects the HEPEVT common block and looks for 
    // inconsistencies in the mother/daughter pointers
    bool isConsistent=true;
    char header[81];
    sprintf( header,
             "\n\n\t**** WARNINGInconsistent HEPEVT input, Event %10d ****"
	     , CBhepevt::event_number() );

    for ( int i = 1; i <= CBhepevt::number_entries(); ++i ) {
	// 1. check its mothers
	int moth1 = CBhepevt::first_parent( i );
	int moth2 = CBhepevt::last_parent( i );
	if ( moth2<moth1 ) {
	    if ( isConsistent ) {
		os << header << std::endl;
		isConsistent = false;
		print_legend(os);
	    }
	    os << "Inconsistent entry " << i 
	       << " first parent > last parent " << std::endl;
	    CBhepevt::printHEPEVTparticle( i, os );
	}
	for ( int m = moth1; m<=moth2 && m!=0; ++m ) {
	    if ( m>CBhepevt::number_entries() || m < 0 ) {
		if ( isConsistent ) {
		    os << header << std::endl;
		    isConsistent = false;
		    print_legend(os);
		}
		os << "Inconsistent entry " << i 
		   << " mother points out of range " << std::endl;
		CBhepevt::printHEPEVTparticle( i, os );
	    }
	    int mChild1 = CBhepevt::first_child(m);
	    int mChild2 = CBhepevt::last_child(m);
	    // we don't consider null pointers as inconsistent
	    if ( mChild1==0 && mChild2==0 ) continue;
	    if ( i<mChild1 || i>mChild2 ) {
		if ( isConsistent ) {
		    os << header << std::endl;
		    isConsistent = false;
		    print_legend(os);
		}
		os << "Inconsistent mother-daughter relationship between "
		   << i << " & " << m 
		   << " (try !trustMother)" << std::endl;
		CBhepevt::printHEPEVTparticle( i, os );
		CBhepevt::printHEPEVTparticle( m, os );
	    }
	}
	// 2. check its daughters
	int dau1 = CBhepevt::first_child( i );
	int dau2 = CBhepevt::last_child( i );
	if ( dau2<dau1 ) {
	    if ( isConsistent ) {
		os << header << std::endl;
		isConsistent = false;
		print_legend(os);
	    }
	    os << "Inconsistent entry " << i 
	       << " first child > last child " << std::endl;
	    CBhepevt::printHEPEVTparticle( i, os );
	}
	for ( int d = dau1; d<=dau2 && d!=0; ++d ) {
	    if ( d>CBhepevt::number_entries() || d < 0 ) {
		if ( isConsistent ) {
		    os << header << std::endl;
		    isConsistent = false;
		    print_legend(os);
		}
		os << "Inconsistent entry " << i 
		   << " child points out of range " << std::endl;
		CBhepevt::printHEPEVTparticle( i, os );
	    }
	    int d_moth1 = CBhepevt::first_parent(d);
	    int d_moth2 = CBhepevt::last_parent(d);
	    // we don't consider null pointers as inconsistent
	    if ( d_moth1==0 && d_moth2==0 ) continue;
	    if ( i<d_moth1 || i>d_moth2 ) {
		if ( isConsistent ) {
		    os << header << std::endl;
		    isConsistent = false;
		    print_legend(os);
		}
		os << "Inconsistent mother-daughter relationship between "
		   << i << " & " << d 
		   << " (try trustMothers)"<< std::endl;
		CBhepevt::printHEPEVTparticle( i, os );
		CBhepevt::printHEPEVTparticle( d, os );
	    }
	}
    }
    if (!isConsistent) {
	os << "Above lists all the inconsistencies in the HEPEVT common "
	   << "\n block which has been provided as input to HepMC. "
	   << "\n HepMC WILL have trouble interpreting the mother-daughter"
	   << "\n relationships ... but all other information "
	   << "\n (4-vectors etc) will be correctly transferred."
	   << "\n In order for HepMC to be able to interpret the mother/"
	   << "\n daughter hierachy, it MUST be given consistent input."
	   << "\n This is one of the design criteria of HepMC: "
	   << "\n consistency is enforced by the code.";
	os << "\nThere is a switch in CBhepevt, set-able using "
	   << "\n CBhepevt::setTrustMothers( bool )"
	   << "\n which you may want to try.";
	os << "\nNote: if HEPEVT common block has been filled by pythia"
	   << "\n pyhepc, then the switch MSTP(128)=2 should be used in"
	   << "\n pythia, which instructs pythia not to put multiple "
	   << "\n copies of resonances in the event record.\n";
	os << "To obtain a file summarizing the inconsistency, you should:"
	   << "\n\t ofstream myFile(\"myInconsistentEvent.txt\"); "
	   << "\n\t CBhepevt::check_hepevt_consistency(myFile); "
	   << "\n\t CBhepevt::printHEPEVT(myFile); "
	   << "\n[now write the event to HepMC using something like"
	   << "\n\t\t myIO_HEPEVT->write_event(myEvent); ]"
	   << "\n\t myEvent->print( myFile ); "
	   << "      // print event as HepMC sees it"
	   << "\n ------------------------- Thank-you. \n\n" << std::endl;
    }
    return isConsistent;
}

void CBhepevt::clean(  )
{
    int i, k;
    hptr->nevhep = 0;
    hptr->nhep = 0;
    hptr2->nmulti = 0;
    hptr4->eventweightlh = 0;
    hptr4->alphaqedlh = -1.;
    hptr4->alphaqcdlh = -1.;
    hptr4->idruplh = 0;
    for( i = 0; i < max_number_entries(); ++i ) {
	hptr->isthep[i] = 0;
	hptr->idhep[i] = 0;
	hptr->jmohep[i][0] = 0;
	hptr->jmohep[i][1] = 0;
	hptr->jdahep[i][0] = 0;
	hptr->jdahep[i][1] = 0;
	hptr->phep[i][0] = 0;
	hptr->phep[i][1] = 0;
	hptr->phep[i][2] = 0;
	hptr->phep[i][3] = 0; 
	hptr->phep[i][4] = 0; 
	hptr->vhep[i][0] = 0;
	hptr->vhep[i][1] = 0;
	hptr->vhep[i][2] = 0;
	hptr->vhep[i][3] = 0;
	hptr2->jmulti[i] = 0;
        hptr4->spinlh[i][0] = 0;
        hptr4->spinlh[i][1] = 0;
        hptr4->spinlh[i][2] = 0;
        hptr4->icolorflowlh[i][0] = 0;
        hptr4->icolorflowlh[i][1] = 0;
    }
    for( i = 0; i < 10; ++i ) {
        hptr4->scalelh[i] = -1.;
    }
    for( i = 0; i < max_multiple_interactions(); ++i ) {
	hptr3->nevmulti[i] = 0;
	hptr3->itrkmulti[i] = 0;
	hptr3->mltstr[i] = 0;
	hptr5->eventweightmulti[i] = 0;
	hptr5->alphaqedmulti[i] = 0;
	hptr5->alphaqcdmulti[i] = 0;
	hptr5->idrupmulti[i] = 0;
        for( k = 0; k < 10; ++k ) {
	    hptr5->scalemulti[i][k] = 0;
	}
    }
}

}	// HepMC
