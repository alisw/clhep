// ----------------------------------------------------------------------
//
// fromGenEvent.icc
//
//  builds HEPEVT from the information in GenEvent
//
// ----------------------------------------------------------------------

#include <iostream>
#include <set>
#include <vector>

namespace HepMC {

bool CBhepevt::fromGenEvent( const GenEvent* evt ) {
    // This writes an event out to the HEPEVT common block. The daughters
    // field is NOT filled, because it is possible to contruct graphs
    // for which the mothers and daughters cannot both be make sequential.
    // This is consistent with how pythia fills HEPEVT (daughters are not
    // necessarily filled properly).
    //
    if ( !evt ) return false;
    //  clean the common block
    clean();
    //
    // map all particles onto a unique index
    std::vector<GenParticle*> index_to_particle(
	max_number_entries()+1 );
    index_to_particle[0]=0;
    std::map<GenParticle*,int> particle_to_index;
    int particle_counter=0;
    for ( GenEvent::vertex_const_iterator v = evt->vertices_begin();
	  v != evt->vertices_end(); ++v ) {
	// all "mothers" or particles_in are kept adjacent in the list
	// so that the mother indices in hepevt can be filled properly
	for ( GenVertex::particles_in_const_iterator p1 
		  = (*v)->particles_in_const_begin();
	      p1 != (*v)->particles_in_const_end(); ++p1 ) {
	    ++particle_counter;
	    if ( particle_counter > 
		 max_number_entries() ) break; 
	    index_to_particle[particle_counter] = *p1;
	    particle_to_index[*p1] = particle_counter;
	}
	// daughters are entered only if they aren't a mother of 
	// another vtx
	for ( GenVertex::particles_out_const_iterator p2 
		  = (*v)->particles_out_const_begin();
	      p2 != (*v)->particles_out_const_end(); ++p2 ) {
	    if ( !(*p2)->end_vertex() ) {
		++particle_counter;
		if ( particle_counter > 
		     max_number_entries() ) {
		    break;
		}
		index_to_particle[particle_counter] = *p2;
		particle_to_index[*p2] = particle_counter;
	    }
	}
    }
    if ( particle_counter > max_number_entries() ) {
	particle_counter = max_number_entries();
    }
    // 	
    // fill the HEPEVT event record
    hptr->nevhep = ( evt->event_number() );
    // these do not have the correct defaults if hepev4 is not filled
    //hptr4->scalelh[1] = ( evt->event_scale() );
    //hptr4->alphaqcdlh = ( evt->alphaQCD() );
    //hptr4->alphaqedlh = ( evt->alphaQED() );
    hptr->nhep = ( particle_counter );
    for ( int i = 1; i <= particle_counter; ++i ) {
	hptr->isthep[i-1] = index_to_particle[i]->status();
	hptr->idhep[i-1] = index_to_particle[i]->pdg_id();
	CLHEP::HepLorentzVector m = index_to_particle[i]->momentum();
	hptr->phep[i-1][0] = m.px();
	hptr->phep[i-1][1] = m.py();
	hptr->phep[i-1][2] = m.pz();
	hptr->phep[i-1][3] = m.e(); 
	hptr->phep[i-1][4] = index_to_particle[i]->generatedMass();
	if ( index_to_particle[i]->production_vertex() ) {
	    CLHEP::HepLorentzVector p = index_to_particle[i]->
				 production_vertex()->position();
	    hptr->vhep[i-1][0] = p.x();
	    hptr->vhep[i-1][1] = p.y();
	    hptr->vhep[i-1][2] = p.z();
	    hptr->vhep[i-1][3] = p.t();
	    int num_mothers = index_to_particle[i]->production_vertex()->
			      particles_in_size();
	    int first_mother = find( particle_to_index,
					    *(index_to_particle[i]->
					      production_vertex()->
					      particles_in_const_begin()));
	    int last_mother = first_mother + num_mothers - 1;
	    if ( first_mother == 0 ) last_mother = 0;
	    hptr->jmohep[i-1][0] = first_mother;
	    hptr->jmohep[i-1][1] = last_mother;
	} else {
	    hptr->vhep[i-1][0] = 0;
	    hptr->vhep[i-1][1] = 0;
	    hptr->vhep[i-1][2] = 0;
	    hptr->vhep[i-1][3] = 0;
	    hptr->jmohep[i-1][0] = 0;
	    hptr->jmohep[i-1][1] = 0;
	}
	hptr->jdahep[i-1][0] = 0;
	hptr->jdahep[i-1][1] = 0;
    }
    return true;
}

// for internal use only
int  CBhepevt::find( const std::map<GenParticle*,int>& m, GenParticle* p)
{
    std::map<GenParticle*,int>::const_iterator iter = m.find(p);
    if ( iter == m.end() ) return 0;
    return iter->second;
}


}	// HepMC
