// $Id: TableBuilderTEvtGen.icc,v 1.1.1.1.4.2 2005/03/18 22:26:26 garren Exp $
// ----------------------------------------------------------------------
//
// TableBuilderTEvtGen.icc
// Author: Lynn Garren
//
// ----------------------------------------------------------------------

namespace HepPDT {

bool getEvtGenLineType( std::string & ltype, int & id, std::string & name, const std::string & pdline );
void parseEvtGenLine( TempParticleData & tpd, const std::string & pdline );
void parseEvtGenAlias( TempAliasData & tad, const std::string & pdline );
bool parseEvtGenDecayLine( TempParticleData & tpd, const std::string & pdline );
bool parseEvtGenAliasDecayLine( TempAliasData & tad, const std::string & pdline );
void parseEvtGenConj( std::string & cname, const std::string & pdline );
void parseEvtGenDefinition( std::string & def, double & val, const std::string & pdline );

template< class Config >
void findDecayModel( TempParticleData & tpd, TableBuilderT<Config> & tb );
template< class Config >
void findAliasDecayModel( TempAliasData & tad, TableBuilderT<Config> & tb );

template< class Config >
bool  addEvtGenParticles( std::istream & pdfile, TableBuilderT<Config> & tb )
{ 
  std::string pdline, ltype, def, name, cname;
  int id, eid;
  double val;
  TempAliasData tad;
  // get definition table
  DefTable & dt = tb.definitions();
  // read and parse each line
  while( std::getline( pdfile, pdline) ) {
    if( getEvtGenLineType( ltype, eid, name, pdline ) ) {
      if( ltype == "add" ) {
          // this is a new particle definition
          id = translateEvtGentoPDT( eid );
          TempParticleData& tpd = tb.getParticleData( ParticleID( id ) );
          parseEvtGenLine( tpd, pdline );
	  tb.addParticle( tpd );
      } else if( ltype=="Define" ) {
          // EvtGen definition
          parseEvtGenDefinition( def, val, pdline );
          dt.addDefinition( def, val );
      } else if( ltype=="Alias" ) {
          // EvtGen alias information
	  TempAliasData ntad;
	  parseEvtGenAlias( ntad, pdline );
	  tb.addAlias( ntad );
      } else if( ltype=="ChargeConj" ) {
          // EvtGen charge conjugate alias
	  if( tb.hasAlias( name ) ) {
	      parseEvtGenConj( cname, pdline );
              tad = tb.aliasData( name );
	      tad.tempChargeConj = cname;
	  } else {
	      std::cout << "HepPDT TableBuilder: " << name << " is not an alias" << std::endl;
	  }
      } else if( ltype=="Decay" ) {
          // EvtGen assumes that all particles have been defined before
          // they are used in the decay table
	  if( tb.hasParticleData( name ) ) {
              TempParticleData& tpd = tb.getParticleData( name );
	      // read lines until we reach an "Enddecay"
	      while( parseEvtGenDecayLine( tpd, pdline ) ) {
        	  std::getline( pdfile, pdline);
	      }
	      // now sort out the decay information
	      findDecayModel( tpd, tb );
	  } else if( tb.hasAlias( name ) ) {
              // alias decays are maintained separately in temporary storage
              tad = tb.aliasData( name );
	      // read lines until we reach an "Enddecay"
	      while( parseEvtGenAliasDecayLine( tad, pdline ) ) {
        	  std::getline( pdfile, pdline);
	      }
	  } else {
	      std::cout << "HepPDT TableBuilder: could not match name " << name << std::endl;
	  }
      } else if( ltype=="CDecay" ) {
          // have to generate a charge conjugate decay table
      }
    }
  }
  std::cout << "found " << tb.size() << " particles and " 
                   << tb.aliasSize() << " aliases" << std::endl;
  // dt.writeDefinitions();
  return true;
}

template< class Config >
void findDecayModel( TempParticleData & tpd, TableBuilderT<Config> & tb )
{
    unsigned int cit, it, ddend, iend;
    std::string name;
    for( cit=0; cit < tpd.tempDecayList.size(); ++cit ) {
        TempDecayData & tdd = tpd.tempDecayList[cit];
	ddend = 0;
	for( it=0; it < tdd.tempDaughterList.size(); ++it ) {
	    name = tdd.tempDaughterList[it];
	    if( tb.hasParticleData( name ) || tb.hasAlias( name ) ) {
	    } else if( ddend == 0 ) {
	        // first item that is not a daughter - must be the model name
		ddend = it;
		tdd.tempDecayName = name;
	    } else {
	        // anything here is a decay parameter
		if( tb.hasDefinition( name ) ) {
		    tdd.tempDecayParameters.push_back( tb.definition( name ) );
		} else {
		    tdd.tempDecayParameters.push_back( stringtodouble( name ) );
		}
	    }
	}
	// now clear out the parameters and model name
	iend = tdd.tempDaughterList.size() - 1;
	for( it = iend; it > ddend; --it ) {
	    tdd.tempDaughterList.pop_back();
	}
    }
}

template< class Config >
void findAliasDecayModel( TempAliasData & tad, TableBuilderT<Config> & tb )
{
    unsigned int cit, it, ddend, iend;
    std::string name;
    for( cit=0; cit < tad.tempAliasDecayList.size(); ++cit ) {
        TempDecayData & tdd = tad.tempAliasDecayList[cit];
	ddend = 0;
	for( it=0; it < tdd.tempDaughterList.size(); ++it ) {
	    name = tdd.tempDaughterList[it];
	    if( tb.hasParticleData( name ) || tb.hasAlias( name ) ) {
	    } else if( ddend == 0 ) {
	        // first item that is not a daughter - must be the model name
		ddend = it;
		tdd.tempDecayName = name;
	    } else {
	        // anything here is a decay parameter
		if( tb.hasDefinition( name ) ) {
		    tdd.tempDecayParameters.push_back( tb.definition( name ) );
		} else {
		    tdd.tempDecayParameters.push_back( stringtodouble( name ) );
		}
	    }
	}
	// now clear out the parameters and model name
	iend = tdd.tempDaughterList.size() - 1;
	for( it = iend; it > ddend; --it ) {
	    tdd.tempDaughterList.pop_back();
	}
    }
}

}  // namespace HepPDT
