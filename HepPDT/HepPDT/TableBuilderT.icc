// $Id: TableBuilderT.icc,v 1.2.4.1 2004/05/19 22:59:10 garren Exp $
// ----------------------------------------------------------------------
//
// TableBuilderT.icc
// Author: Lynn Garren
//
// ----------------------------------------------------------------------

#include "CLHEP/HepPDT/defs.h"
#if HAVE_SSTREAM
#include <sstream>
#else
#include "CLHEP/HepPDT/StringStream.h"
#endif

namespace HepPDT {

template< class Config >
void TableBuilderT<Config>::fillPDT()
{ ; }

template< class Config >
void  TableBuilderT<Config>::reverseEngineer()
{ ; }

template< class Config >
TempParticleData &   TableBuilderT<Config>::getParticleData( ParticleID pid )  
{
  TempMap::iterator it = tempPDT.find( pid );
  // for some reason, Solaris CC can't cope with the more compact code
  if ( it == tempPDT.end() ) {
     return tempPDT[pid] = TempParticleData(pid);
  } else {
     return it->second;   
  }
  //return ( it == tempPDT.end() )
  //     ?  tempPDT[pid] = TempParticleData(pid)  // new one
  //     :  it->second;                           // old one
}

template< class Config >
TempParticleData &  TableBuilderT<Config>::getParticleData( std::string const & name )  
{
    TempIDMap::iterator it = tempIDT.find( name );
    if( it == tempIDT.end() ) {
        // can neither build nor return a proper TempParticleData
	os << "HepPDT::TableBuilder.getParticleData: There is no entry for " << name << std::endl;
        exit(-3);
    }
    ParticleID pid = it->second;
    return getParticleData( pid );
}

template< class Config >
TempParticleData &  TableBuilderT<Config>::getAntiParticle( ParticleID pid, 
                                                    const std::string & aname )
{
    // is it already here?
    ParticleID apid = ParticleID( -pid.pid() );
    TempMap::iterator it = tempPDT.find( apid );
    if( it != tempPDT.end() ) {
        return it->second;
    }
    // check for original particle to copy
    it = tempPDT.find( pid );
    if( it == tempPDT.end() ) {
        // no particle to copy
	TempParticleData atpd = getParticleData( apid );
	atpd.tempParticleName = aname;
	return tempPDT[apid] = atpd;	// getParticleData already added it to the map
    } else {
        // copy original
	TempParticleData tpd = it->second;
	TempParticleData atpd = tpd.antiparticle( aname );
        return tempPDT[apid] = atpd;	// add to map and return
    }
}

template< class Config >
bool TableBuilderT<Config>::hasParticleData( std::string const & name )
{
    TempIDMap::iterator it = tempIDT.find( name );
    return ( it == tempIDT.end() ) ?  false  : true;
}

template< class Config >
bool TableBuilderT<Config>::hasAlias( std::string const & alias )
{
    TempAliasMap::iterator it = tempAliases.find( alias );
    return ( it == tempAliases.end() ) ?  false  : true;
}

template< class Config >
void  TableBuilderT<Config>::addParticle( TempParticleData const & pd )  {
  getParticleData( pd.tempID ) = pd;
  if( !hasParticleData( pd.tempParticleName ) ) {
      tempIDT[pd.tempParticleName] = pd.tempID;
  }
}


template< class Config >
void TableBuilderT<Config>::addAlias( TempAliasData const & ad )
{
    std::string alias = ad.tempAlias;
    tempAliases[alias] = ad;
}

template< class Config >
TempAliasData& TableBuilderT<Config>::aliasData( std::string const & alias )
{
    TempAliasMap::iterator it = tempAliases.find( alias );
    if( it == tempAliases.end() ) {
        // can neither build nor return a proper TempParticleData
	os << "HepPDT::TableBuilder.aliasData: There is no entry for " 
                       << alias << std::endl;
        exit(-4);
    }
    return it->second;
}

// --- free functions
//

void getPDGpid( std::vector<int> & idlist,  std::string & pdline );
void parsePDGline( TempParticleData & tpd,  std::string & pdline );

template< class Config >
bool  addPDGParticles( std::istream & pdfile, TableBuilderT<Config> & tb )
{
  // mass and width lines can be in any order
  std::vector<int> idlist;
  std::string pdline;
  // read and parse each line
  while( std::getline( pdfile, pdline) ) {
    getPDGpid( idlist, pdline );
    for( unsigned int i = 0; i < idlist.size(); ++i )
    {
        TempParticleData& tpd = tb.getParticleData( ParticleID( idlist[i] ) );
        parsePDGline( tpd, pdline );
    }
  }
  std::cout << "found " << tb.size() << " particles" << std::endl;
  return true;
}

}  // namespace HepPDT
