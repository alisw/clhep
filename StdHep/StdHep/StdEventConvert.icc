// ----------------------------------------------------------------------
//
// StdEventConvert.icc
// L. Garren
//
//  build StdEvent from HEPEVT, and vice-versa
//
// ----------------------------------------------------------------------

namespace StdHep {

template<class S>
StdEvent * StdEventConvert< S >::getStdEvent( int & evnum )
{
    HepMC::GenEvent* col = toCollision();
    if( !col ) return NULL;
    // make a vector of Collisions
    StdEvent::CollisionList cvect;
    cvect.push_back( col );
    return new StdEvent( evnum, cvect );
}

template<class S>
HepMC::GenEvent * StdEventConvert< S >::toCollision()
{
    // create and fill a new GenEvent
    // 
    // create an empty event container
    HepMC::GenEvent* col = new HepMC::GenEvent();
    // test that col pointer is not null
    if ( !col ) {
	std::cerr 
	    << "StdEventConvert:toGenEvent: error - passed null event." 
	    << std::endl;
	return NULL;
    }
    // 2. fill the col container - if the read is successful, return the
    //    pointer, otherwise return null and delete the col
    HepMC::CBInterface< S > * hep = HepMC::CBInterface< S >::instance();
    bool perr = printInconsistencyErrors();
    if ( (*hep)->toGenEvent( col, perr ) ) return col;
    // note: this delete is only reached if read fails
    delete col;
    return NULL;
}

template<class S>
bool StdEventConvert< S >::fromStdEvent( const StdEvent * evt )
{
    if ( !evt ) return false;
    //  get the common block and clean it
    HepMC::CBInterface< S > * hep = HepMC::CBInterface< S >::instance();
    (*hep)->clean( );
    return (*hep)->fromStdEvent( evt );
}

} // StdHep
