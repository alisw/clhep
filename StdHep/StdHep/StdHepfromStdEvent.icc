// $Id: StdHepfromStdEvent.icc,v 1.2 2003/08/29 02:06:13 garren Exp $
// ----------------------------------------------------------------------
// HEPEVTfromStdEvent.icc
// ----------------------------------------------------------------------
// Author:  Lynn Garren, Marc Paterno,
//

#include "CLHEP/HepMC/GenParticle.h"

namespace StdHep  {

bool CBstdhep::fromStdEvent( const StdEvent * evt )
{
    // make sure we have data
    int ncol = evt->size();
    if( ncol < 1 ) return false;
    // set event number
    hptr->nevhep = evt->eventNumber();
    // loop over Collisions
    for( int i=0; i<ncol; ++i) {
        HepMC::GenEvent* col = evt->collision(i);
        if( CollisionToStdTmp( col ) ) {
	    if( !MultipleInteractionInfo(i) ) return false;
	}
    }
    return true;
}

bool CBstdhep::CollisionToStdTmp( const HepMC::GenEvent * col )
{
    // fill the temporary stdtmp common block with the information in GenEvent
    //
    if ( !col ) return false;
    //  clean stdtmp
    cleanStdtmp( );
    //
    // map all particles onto a unique index
    std::vector<HepMC::GenParticle*> index_to_particle( max_number_entries()+1 );
    index_to_particle[0]=0;
    std::map<HepMC::GenParticle*,int> particle_to_index;
    int particle_counter=0;
    for ( HepMC::GenEvent::vertex_const_iterator v = col->vertices_begin();
	  v != col->vertices_end(); ++v ) {
	// all "mothers" or particles_in are kept adjacent in the list
	// so that the mother indices in hepevt can be filled properly
	for ( HepMC::GenVertex::particles_in_const_iterator p1 
		  = (*v)->particles_in_const_begin();
	      p1 != (*v)->particles_in_const_end(); ++p1 ) {
	    ++particle_counter;
	    if ( particle_counter > max_number_entries() ) break; 
	    index_to_particle[particle_counter] = *p1;
	    particle_to_index[*p1] = particle_counter;
	}
	// daughters are entered only if they aren't a mother of 
	// another vtx
	for ( HepMC::GenVertex::particles_out_const_iterator p2 
		  = (*v)->particles_out_const_begin();
	      p2 != (*v)->particles_out_const_end(); ++p2 ) {
	    if ( !(*p2)->end_vertex() ) {
		++particle_counter;
		if ( particle_counter > max_number_entries() ) break;
		index_to_particle[particle_counter] = *p2;
		particle_to_index[*p2] = particle_counter;
	    }
	}
    }
    if ( particle_counter > max_number_entries() ) {
	particle_counter = max_number_entries();
    }
    // 	
    // fill the HEPEVT event record
    tptr->nevhept = ( col->event_number() );
    tptr4->scalet[1] = ( col->event_scale() );
    tptr4->alphaqcdt = ( col->alphaQCD() );
    tptr4->alphaqedt = ( col->alphaQED() );
    tptr->nhept = ( particle_counter );
    for ( int i = 1; i <= particle_counter; ++i ) {
	tptr->isthept[i-1] = index_to_particle[i]->status();
	tptr->idhept[i-1] = index_to_particle[i]->pdg_id();
	CLHEP::HepLorentzVector m = index_to_particle[i]->momentum();
	tptr->phept[i-1][0] = m.px();
	tptr->phept[i-1][1] = m.py();
	tptr->phept[i-1][2] = m.pz();
	tptr->phept[i-1][3] = m.e(); 
	tptr->phept[i-1][4] = index_to_particle[i]->generatedMass();
	if ( index_to_particle[i]->production_vertex() ) {
	    CLHEP::HepLorentzVector p = index_to_particle[i]->
				 production_vertex()->position();
	    tptr->vhept[i-1][0] = p.x();
	    tptr->vhept[i-1][1] = p.y();
	    tptr->vhept[i-1][2] = p.z();
	    tptr->vhept[i-1][3] = p.t();
	    int num_mothers = index_to_particle[i]->production_vertex()->
			      particles_in_size();
	    int first_mother = findInTemporaryMap( particle_to_index,
					    *(index_to_particle[i]->
					      production_vertex()->
					      particles_in_const_begin()));
	    int last_mother = first_mother + num_mothers - 1;
	    if ( first_mother == 0 ) last_mother = 0;
	    tptr->jmohept[i-1][0] = first_mother;
	    tptr->jmohept[i-1][1] = last_mother;
	} else {
	    tptr->vhept[i-1][0] = 0;
	    tptr->vhept[i-1][1] = 0;
	    tptr->vhept[i-1][2] = 0;
	    tptr->vhept[i-1][3] = 0;
	    tptr->jmohept[i-1][0] = 0;
	    tptr->jmohept[i-1][1] = 0;
	}
	tptr->jdahept[i-1][0] = 0;
	tptr->jdahept[i-1][1] = 0;
    }
    return true;
}
bool CBstdhep::MultipleInteractionInfo( int & mlt )
{
    //
    if( ( hptr->nhep + tptr->nhept ) > max_number_entries() ) return false;
    //
    int i, k, ind;
    hptr4->idruplh = tptr4->idrupt;
    hptr4->eventweightlh = tptr4->eventweightt;
    hptr4->alphaqedlh = tptr4->alphaqedt;
    hptr4->alphaqcdlh = tptr4->alphaqcdt;
    for( i=0; i<10; ++i ) {
	hptr4->scalelh[i] = tptr4->scalet[i];
    }
    for( i=0; i<tptr->nhept; ++i ) {
        ind = i + hptr->nhep;
	hptr->isthep[ind] = tptr->isthept[i];
	hptr->idhep[ind] = tptr->idhept[i];
        for( k=0; k<2; ++k ) {
          hptr->jmohep[ind][k] = tptr->jmohept[i][k];
          hptr->jdahep[ind][k] = tptr->jdahept[i][k];
	  hptr4->icolorflowlh[ind][k] = tptr4->icolorflowt[i][k];
	}
        for( k=0; k<5; ++k ) {
          hptr->phep[ind][k] = tptr->phept[i][k];
	}
        for( k=0; k<4; ++k ) {
          hptr->vhep[ind][k] = tptr->vhept[i][k];
	}
        for( k=0; k<3; ++k ) {
          hptr4->spinlh[ind][k] = tptr4->spint[i][k];
	}
    }
    // check the number of interactions
    hptr2->nmulti = mlt;
    if( mlt > max_multiple_interactions() ) return false;
    hptr3->nevmulti[mlt] = tptr->nevhept;
    hptr3->itrkmulti[mlt] = hptr->nhep + 1;
    hptr3->mltstr[mlt] = mlt;
    hptr5->idrupmulti[mlt] = tptr4->idrupt;
    hptr5->eventweightmulti[mlt] = tptr4->eventweightt;
    hptr5->alphaqedmulti[mlt] = tptr4->alphaqedt;
    hptr5->alphaqcdmulti[mlt] = tptr4->alphaqcdt;
    for( i=0; i<10; ++i ) {
	hptr5->scalemulti[mlt][i] = tptr4->scalet[i];
    }
    // adjust "pointers"
    for( i=0; i<tptr->nhept; ++i ) {
        ind = i + hptr->nhep;
        hptr2->jmulti[ind] = mlt;
        for( k=0; k<2; ++k ) {
            if(hptr->jmohep[ind][k] != 0) 
     	           hptr->jmohep[ind][k] = hptr->jmohep[ind][k] 
		                                  + hptr->nhep;
            if(hptr->jdahep[ind][k] != 0)
     	           hptr->jdahep[ind][k] = hptr->jdahep[ind][k] 
		                                  + hptr->nhep;
            if(hptr4->icolorflowlh[ind][k] != 0)
     	           hptr4->icolorflowlh[ind][k] = hptr4->icolorflowlh[ind][k] 
		                                        + hptr->nhep;
        }
    }
    // now adjust number of events
    hptr->nhep += tptr->nhept;
    return true;
}

int CBstdhep::findInTemporaryMap( const std::map<HepMC::GenParticle*,int>& m, 
                                  HepMC::GenParticle* p)
{
    std::map<HepMC::GenParticle*,int>::const_iterator iter = m.find(p);
    if ( iter == m.end() ) return 0;
    return iter->second;
}

}	// StdHep
