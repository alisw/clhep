// $Id: StdRunInfoConvert.icc,v 1.1.1.1.2.2 2005/03/14 17:36:31 garren Exp $
// ----------------------------------------------------------------------
//
// StdRunInfoConvert.icc
// L. Garren
//
//  defines free functions to build StdRunInfo from HEPEVT, and vice-versa
//  random seeds are saved as a pair of doubles in the stdcm1 common block
//
// ----------------------------------------------------------------------

#include "CLHEP/StdHep/CBcm.hh"
#include "CLHEP/HepMC/CBInterface.h"
#include "CLHEP/HepMC/DoubleConversion.hh"

namespace StdHep {

typedef  HepMC::CBInterface< CBcm >  FIcm;

StdRunInfo * getRunInfoFromSTDCM( int irun )
{
    FIcm * cm = FIcm::instance();
    StdRunInfo * run = new StdRunInfo( irun, (*cm)->stdcm1()->nevtreq,
                                 (*cm)->stdcm1()->nevtgen,
                                 (*cm)->stdcm1()->nevtwrt,
                                 (double)(*cm)->stdcm1()->stdecom,
                                 (double)(*cm)->stdcm1()->stdxsec );
    // convert doubles to longs and save
    std::vector<unsigned long> state(4);
    DoubleConversion::dto2longs((*cm)->stdcm1()->stdseed1,*state[0],*state[1]);
    DoubleConversion::dto2longs((*cm)->stdcm1()->stdseed2,*state[2],*state[3]);
    run->saveSeeds( state );
    // save names
    std::string gname = (*cm)->stdcm2()->generatorname;
    std::string pname = (*cm)->stdcm2()->pdfname;
    run->setGeneratorName( gname );
    run->setPdfName( pname );
    return run;
}

bool RunInfoToSTDCM( StdRunInfo * run )
{
    FIcm * cm = FIcm::instance();
    (*cm)->stdcm1()->nevtreq = run->eventsToGenerate();
    (*cm)->stdcm1()->nevtgen = run->eventsGenerated();
    (*cm)->stdcm1()->nevtwrt = run->eventsWritten();
    (*cm)->stdcm1()->stdecom = (float)run->CoMEnergy();
    (*cm)->stdcm1()->stdxsec = (float)run->crossSection();
    // convert longs to double
    std::vector<unsigned long> state = run->seedArray();
    std::vector<double> result;
    for( unsigned int i=0; i<(itsSeedList.size()-1); ++i ) {
       dd = DoubleConversion::longs2double(*state[i],*state[i+1]);
       ++i;
       result.push_back(dd);
    }
    if( run->size() > 1 ) (*cm)->stdcm1()->stdseed1 = result[0];
    if( run->size() > 3 ) (*cm)->stdcm1()->stdseed2 = result[1];
    // check run number
    if( run->runNumber() == 0 ) return false;
    return true;
}

} // StdHep

