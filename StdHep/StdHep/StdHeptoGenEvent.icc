// ----------------------------------------------------------------------
//
// StdHeptoHepMC::GenEvent.icc
// Author:  Lynn Garren
//
//  builds HepMC::GenEvent from the information in HEPEVT
//
// ----------------------------------------------------------------------

#include <iostream>
#include <set>
#include <vector>

namespace StdHep {

bool CBstdhep::toGenEvent( HepMC::GenEvent* evt, bool printErrors ) {
    // read one event from the HEPEVT common block and fill HepMC::GenEvent
    // return T/F =success/failure
    //
    // For HEPEVT commons built with the luhepc routine of Pythia 5.7
    //  the children pointers are not always correct (i.e. there is 
    //  oftentimes an internal inconsistency between the parents and 
    //  children pointers). The parent pointers always seem to be correct.
    // Thus the switch trust_mothers_before_daughters=1 is appropriate for
    //  pythia. NOTE: you should also set the switch MSTP(128) = 2 in 
    //                pythia (not the default!), so that pythia doesn't
    //                store two copies of resonances in the event record.
    // The situation is opposite for the HEPEVT which comes from Isajet
    // via stdhep, so then use the switch trust_mothers_before_daughters=0
    //
    evt->set_event_number( hptr->nevhep );
    // these do not have the correct defaults if hepev4 is not filled
    //evt->set_event_scale( hepev4()->scalelh[1] );
    //evt->set_alphaQCD( hepev4()->alphaqcdlh );
    //evt->set_alphaQED( hepev4()->alphaqedlh );
    //
    // 2. create a particle instance for each HEPEVT entry and fill a map
    //    create a vector which maps from the HEPEVT particle index to the 
    //    HepMC::GenParticle address
    //    (+1 in size accounts for hepevt_particle[0] which is unfilled)
    std::vector<HepMC::GenParticle*> hepevt_particle( hptr->nhep+1 );
    hepevt_particle[0] = 0;
    for ( int i1 = 1; i1 <= hptr->nhep; ++i1 ) {
	hepevt_particle[i1] = createParticle(i1);
    }
    std::set<HepMC::GenVertex*> new_vertices;
    //
    // 3.+4. loop over HEPEVT particles AGAIN, this time creating vertices
    for ( int i = 1; i <= hptr->nhep; ++i ) {
	// We go through and build EITHER the production or decay 
	// vertex for each entry in hepevt, depending on the switch
	// trustMothers() (new 2001-02-28)
	// Note: since the HEPEVT pointers are bi-directional, it is
	///      sufficient to do one or the other.
	//
	// 3. Build the production_vertex (if necessary)
	if ( trustMothers() ) {
	    buildProductionVertex( i, hepevt_particle, evt, printErrors );
	}
	//
	// 4. Build the end_vertex (if necessary) 
	//    Identical steps as for production vertex
	if ( !trustMothers() ) {
	    buildEndVertex( i, hepevt_particle, evt, printErrors );
	}
    }
    // 5.             01.02.2000
    // handle the case of particles in HEPEVT which come from nowhere -
    //  i.e. particles without mothers or daughters.
    //  These particles need to be attached to a vertex, or else they
    //  will never become part of the event. check for this situation
    for ( int i3 = 1; i3 <= hptr->nhep; ++i3 ) {
	if ( !hepevt_particle[i3]->end_vertex() && 
		    !hepevt_particle[i3]->production_vertex() ) {
	    HepMC::GenVertex* prod_vtx = new HepMC::GenVertex();
	    prod_vtx->add_particle_out( hepevt_particle[i3] );
	    evt->add_vertex( prod_vtx );
	}
    }
    return true;
}

// for internal use only
HepMC::GenParticle* CBstdhep::createParticle( int index ) {
    // Builds a particle object corresponding to index in HEPEVT
    // 
    HepMC::GenParticle* p 
	= new HepMC::GenParticle( CLHEP::HepLorentzVector( hptr->phep[index-1][0], 
					     hptr->phep[index-1][1], 
					     hptr->phep[index-1][2], 
					     hptr->phep[index-1][3] ),
			   hptr->idhep[index-1], 
			   hptr->isthep[index-1] );
    p->setGeneratedMass( hptr->phep[index-1][4] );
    p->suggest_barcode( index );
    return p;
}

// for internal use only
void CBstdhep::buildProductionVertex( int i, 
                            std::vector<HepMC::GenParticle*>& hepevt_particle, 
		            HepMC::GenEvent* evt, bool printInconsistencyErrors )
{
    // 
    // for particle in HEPEVT with index i, build a production vertex
    // if appropriate, and add that vertex to the event
    HepMC::GenParticle* p = hepevt_particle[i];
    // a. search to see if a production vertex already exists
    int mother = hptr->jmohep[i-1][0];
    // this is dangerous.  Copying null pointer and attempting to fill 
    //  information in prod_vtx......
    HepMC::GenVertex* prod_vtx = p->production_vertex();
    while ( !prod_vtx && mother > 0 ) {
        // this is dangerous.  Copying null pointer and attempting to fill 
	//  information in prod_vtx......
	prod_vtx = hepevt_particle[mother]->end_vertex();
	if ( prod_vtx ) prod_vtx->add_particle_out( p );
	// increment mother for next iteration
	if ( ++mother > hptr->jmohep[i-1][1] ) mother = 0;
    }
    // b. if no suitable production vertex exists - and the particle
    // has atleast one mother or position information to store - 
    // make one
    CLHEP::HepLorentzVector prod_pos( hptr->vhep[i-1][0], hptr->vhep[i-1][1], 
			       hptr->vhep[i-1][2], hptr->vhep[i-1][3]
	                     ); 
    if ( !prod_vtx && (number_parents(i-1)>0 
		       || prod_pos!=CLHEP::HepLorentzVector(0,0,0,0)) )
    {
	prod_vtx = new HepMC::GenVertex();
	prod_vtx->add_particle_out( p );
	evt->add_vertex( prod_vtx );
    }
    // c. if prod_vtx doesn't already have position specified, fill it
    if ( prod_vtx && prod_vtx->position()==CLHEP::HepLorentzVector(0,0,0,0) ) {
	prod_vtx->set_position( prod_pos );
    }
    // d. loop over mothers to make sure their end_vertices are
    //     consistent
    mother = hptr->jmohep[i-1][0];
    while ( prod_vtx && mother > 0 ) {
	if ( !hepevt_particle[mother]->end_vertex() ) {
	    // if end vertex of the mother isn't specified, do it now
	    prod_vtx->add_particle_in( hepevt_particle[mother] );
	} else if (hepevt_particle[mother]->end_vertex() != prod_vtx ) {
	    // problem scenario --- the mother already has a decay
	    // vertex which differs from the daughter's produciton 
	    // vertex. This means there is internal
	    // inconsistency in the HEPEVT event record. Print an
	    // error
	    // Note: we could provide a fix by joining the two 
	    //       vertices with a dummy particle if the problem
	    //       arrises often with any particular generator.
	    if ( printInconsistencyErrors ) std::cerr
		<< "HepMC::CBstdhep: inconsistent mother/daugher "
		<< "information in HEPEVT event " 
		<< hptr->nevhep
		<< "\n This warning can be turned off with the "
		<< "CBstdhep::setInconsitencyErrors switch."
		<< std::endl;
	}
	if ( ++mother > hptr->jmohep[i-1][1] ) mother = 0;
    }
}

// for internal use only
void CBstdhep::buildEndVertex( int iend, 
                               std::vector<HepMC::GenParticle*>& hepevt_particle, 
		               HepMC::GenEvent* evt, bool printInconsistencyErrors )
{
    // 
    // for particle in HEPEVT with index i, build an end vertex
    // if appropriate, and add that vertex to the event
    //    Identical steps as for buildProductionVertex
    HepMC::GenParticle* p = hepevt_particle[iend];
    // a.
    int daughter = hptr->jdahep[iend-1][0];
    HepMC::GenVertex* end_vtx = p->end_vertex();
    while ( !end_vtx && daughter > 0 ) {
	end_vtx = hepevt_particle[daughter]->production_vertex();
	if ( end_vtx ) end_vtx->add_particle_in( p );
	if ( ++daughter > hptr->jdahep[iend-1][1] ) daughter = 0;
    }
    // b. (different from 3c. because HEPEVT particle can not know its
    //        decay position )
    if ( !end_vtx && number_children(iend-1)>0 ) {
	end_vtx = new HepMC::GenVertex();
	end_vtx->add_particle_in( p );
	evt->add_vertex( end_vtx );
    }
    // c+d. loop over daughters to make sure their production vertices 
    //    point back to the current vertex.
    //    We get the vertex position from the daughter as well.
    daughter = hptr->jdahep[iend-1][0];
    while ( end_vtx && daughter > 0 ) {
	if ( !hepevt_particle[daughter]->production_vertex() ) {
	    // if end vertex of the mother isn't specified, do it now
	    end_vtx->add_particle_out( hepevt_particle[daughter] );
	    // 
	    // 2001-03-29 M.Dobbs, fill vertex the position.
	    if ( end_vtx->position()==CLHEP::HepLorentzVector(0,0,0,0) ) {
		CLHEP::HepLorentzVector prod_pos( hptr->vhep[daughter-1][0], 
					   hptr->vhep[daughter-1][1], 
					   hptr->vhep[daughter-1][2], 
					   hptr->vhep[daughter-1][3] 
		    );
		if ( prod_pos != CLHEP::HepLorentzVector(0,0,0,0) ) {
		    end_vtx->set_position( prod_pos );
		}
	    }
	} else if (hepevt_particle[daughter]->production_vertex() 
		   != end_vtx){
	    // problem scenario --- the daughter already has a prod
	    // vertex which differs from the mother's end 
	    // vertex. This means there is internal
	    // inconsistency in the HEPEVT event record. Print an
	    // error
	    if ( printInconsistencyErrors ) {
	        std::cerr
		<< "HepMC::CBstdhep: inconsistent mother/daugher "
		<< "information in HEPEVT event " 
		<< hptr->nevhep
		<< "\n This warning can be turned off with the "
		<< "CBstdhep::setInconsitencyErrors switch."
		<< std::endl;
	    }
	}
	if ( ++daughter > hptr->jdahep[iend-1][1] ) daughter = 0;
    }
    if ( !p->end_vertex() && !p->production_vertex() ) {
	// Added 2001-11-04, to try and handle Isajet problems.
	buildProductionVertex( iend, hepevt_particle, evt, printInconsistencyErrors );
    }
}

}	// StdHep
